ファイル 'kb16_analysis_20250511_013347/kb16_protocol.json' を解析中...
329個のレポートを読み込みました

== ビットマップ解析 ==
変化頻度の高いビットはキーボードの物理ボタンに対応している可能性があります

byte0_bit2: 4回変化
byte1_bit0: 78回変化
byte1_bit1: 44回変化
byte1_bit2: 4回変化
byte2_bit6: 10回変化
byte2_bit4: 10回変化
byte2_bit5: 4回変化
byte3_bit0: 4回変化
byte3_bit3: 2回変化
byte4_bit0: 36回変化
byte4_bit3: 24回変化
byte4_bit7: 24回変化
byte4_bit1: 24回変化
byte4_bit5: 24回変化
byte4_bit6: 22回変化
byte4_bit4: 20回変化
byte4_bit2: 18回変化
byte5_bit5: 80回変化
byte5_bit0: 38回変化
byte5_bit1: 33回変化
byte5_bit3: 24回変化
byte5_bit4: 20回変化
byte5_bit2: 18回変化
byte5_bit6: 18回変化
byte5_bit7: 18回変化
byte7_bit4: 4回変化
byte8_bit5: 2回変化
byte10_bit0: 2回変化
byte11_bit4: 6回変化

== 推測されるキーマトリックス構造 ==
  | 0   | 1   | 2   | 3  
--+-----+-----+-----+-----
0 | byte5_bit5 | byte1_bit0 | byte1_bit1 | byte5_bit0 |
1 | byte4_bit0 | byte5_bit1 | byte4_bit3 | byte4_bit7 |
2 | byte4_bit1 | byte4_bit5 | byte5_bit3 | byte4_bit6 |
3 | byte4_bit4 | byte5_bit4 | byte4_bit2 | byte5_bit2 |

== 個別キー情報 ==
マトリックス位置 (0, 0): byte5_bit5 (変化回数: 80)
マトリックス位置 (0, 1): byte1_bit0 (変化回数: 78)
マトリックス位置 (0, 2): byte1_bit1 (変化回数: 44)
マトリックス位置 (0, 3): byte5_bit0 (変化回数: 38)
マトリックス位置 (1, 0): byte4_bit0 (変化回数: 36)
マトリックス位置 (1, 1): byte5_bit1 (変化回数: 33)
マトリックス位置 (1, 2): byte4_bit3 (変化回数: 24)
マトリックス位置 (1, 3): byte4_bit7 (変化回数: 24)
マトリックス位置 (2, 0): byte4_bit1 (変化回数: 24)
マトリックス位置 (2, 1): byte4_bit5 (変化回数: 24)
マトリックス位置 (2, 2): byte5_bit3 (変化回数: 24)
マトリックス位置 (2, 3): byte4_bit6 (変化回数: 22)
マトリックス位置 (3, 0): byte4_bit4 (変化回数: 20)
マトリックス位置 (3, 1): byte5_bit4 (変化回数: 20)
マトリックス位置 (3, 2): byte4_bit2 (変化回数: 18)
マトリックス位置 (3, 3): byte5_bit2 (変化回数: 18)

== 最頻出レポートパターン ==
パターン 1: 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 (80回, 24.3%)
パターン 2: 06 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 (48回, 14.6%)
パターン 3: 02 00 00 00 00 00 (37回, 11.2%)
パターン 4: 06 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 (28回, 8.5%)
パターン 5: 06 01 00 00 00 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 (17回, 5.2%)

== KB16物理キー配置への推測マッピング ==
KB16キー 0,0 -> 可能性の高いビット: byte5_bit5 (変化回数: 80)
KB16キー 0,1 -> 可能性の高いビット: byte1_bit0 (変化回数: 78)
KB16キー 0,2 -> 可能性の高いビット: byte1_bit1 (変化回数: 44)
KB16キー 0,3 -> 可能性の高いビット: byte5_bit0 (変化回数: 38)
KB16キー 1,0 -> 可能性の高いビット: byte4_bit0 (変化回数: 36)
KB16キー 1,1 -> 可能性の高いビット: byte5_bit1 (変化回数: 33)
KB16キー 1,2 -> 可能性の高いビット: byte4_bit3 (変化回数: 24)
KB16キー 1,3 -> 可能性の高いビット: byte4_bit7 (変化回数: 24)
KB16キー 2,0 -> 可能性の高いビット: byte4_bit1 (変化回数: 24)
KB16キー 2,1 -> 可能性の高いビット: byte4_bit5 (変化回数: 24)
KB16キー 2,2 -> 可能性の高いビット: byte5_bit3 (変化回数: 24)
KB16キー 2,3 -> 可能性の高いビット: byte4_bit6 (変化回数: 22)
KB16キー 3,0 -> 可能性の高いビット: byte4_bit4 (変化回数: 20)
KB16キー 3,1 -> 可能性の高いビット: byte5_bit4 (変化回数: 20)
KB16キー 3,2 -> 可能性の高いビット: byte4_bit2 (変化回数: 18)
KB16キー 3,3 -> 可能性の高いビット: byte5_bit2 (変化回数: 18)

== EspUsbHost.cpp用コード生成 ==
以下のコードをEspUsbHost.cppのキーボード処理関数に統合してみてください:

// キーボードマトリックスマッピング構造体
struct KeyMapping {
    uint8_t byte_idx;  // レポート内のバイトインデックス
    uint8_t bit_mask;  // ビットマスク (1 << bit)
    uint8_t row;       // キーボードマトリックス行
    uint8_t col;       // キーボードマトリックス列
};

// DOIO KB16キーマッピング
const KeyMapping kb16_key_map[] = {
    { 5, 0x20, 0, 0 },  // byte5_bit5
    { 1, 0x01, 0, 1 },  // byte1_bit0
    { 1, 0x02, 0, 2 },  // byte1_bit1
    { 5, 0x01, 0, 3 },  // byte5_bit0
    { 4, 0x01, 1, 0 },  // byte4_bit0
    { 5, 0x02, 1, 1 },  // byte5_bit1
    { 4, 0x08, 1, 2 },  // byte4_bit3
    { 4, 0x80, 1, 3 },  // byte4_bit7
    { 4, 0x02, 2, 0 },  // byte4_bit1
    { 4, 0x20, 2, 1 },  // byte4_bit5
    { 5, 0x08, 2, 2 },  // byte5_bit3
    { 4, 0x40, 2, 3 },  // byte4_bit6
    { 4, 0x10, 3, 0 },  // byte4_bit4
    { 5, 0x10, 3, 1 },  // byte5_bit4
    { 4, 0x04, 3, 2 },  // byte4_bit2
    { 5, 0x04, 3, 3 },  // byte5_bit2
};

// KB16キーボードのレポート解析関数
void onKeyboard(hid_keyboard_report_t report, hid_keyboard_report_t last_report) {
    // 標準HIDキーボードレポート解析（既存のコード）
    
    // DOIO KB16カスタムキー解析
    if (device_product_id == 0x1601 && device_vendor_id == 0xD010) {
        const uint8_t* data = (const uint8_t*)&report;
        const uint8_t* last_data = (const uint8_t*)&last_report;
        bool key_state_changed = false;
        
        // 各キーマッピングをチェック
        for (int i = 0; i < sizeof(kb16_key_map) / sizeof(KeyMapping); i++) {
            const KeyMapping& mapping = kb16_key_map[i];
            
            // バイトインデックスが範囲内か確認
            if (mapping.byte_idx < sizeof(report)) {
                bool current_state = data[mapping.byte_idx] & mapping.bit_mask;
                bool last_state = last_data[mapping.byte_idx] & mapping.bit_mask;
                
                // 状態が変化した場合
                if (current_state != last_state) {
                    key_state_changed = true;
                    ESP_LOGI("KB16", "キー (%d,%d) %s", 
                             mapping.row, mapping.col, 
                             current_state ? "押下" : "解放");
                    
                    // ここでキーの状態変化に応じた処理を実装
                }
            }
        }
        
        if (key_state_changed) {
            // キー状態が変化した場合の全体的な処理
        }
    }
}
