# DOIO KB16 レポートディスクリプタ解析

このドキュメントは、DOIO KB16キーボードのUSB HIDレポートディスクリプタの解析結果をまとめたものです。この情報は、DOIO KB16キーボードとの通信を実装する際に役立ちます。

## 基本情報

- **ベンダーID**: 0xD010
- **プロダクトID**: 0x1601
- **キーボードタイプ**: 4×4マトリックス（16キー）

## レポート形式

DOIO KB16キーボードは標準的なHIDキーボードプロトコルとは異なる、独自のレポート形式を使用しています。以下はその特徴です：

### レポート概要

- 基本的なレポートサイズ: 32バイト（実際には6〜32バイトの範囲で可変）
- 主要データ: 最初の6バイトに集中
- 識別子: `report.reserved` フィールドに特殊な値 `0xAA` が含まれる場合がある

### 最頻出レポートパターン

解析の結果、以下のようなレポートパターンが高頻度で観測されました：

1. `06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00` (80回, 24.3%)
2. `06 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00` (48回, 14.6%)
3. `02 00 00 00 00 00` (37回, 11.2%)
4. `06 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00` (28回, 8.5%)
5. `06 01 00 00 00 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00` (17回, 5.2%)

パターン1は、何もキーが押されていない「アイドル状態」を表していると考えられます。先頭バイトの`06`は、キーボード内部の状態を示している可能性があります。

## キーマトリックスマッピング

解析の結果、各キーの物理的な位置とレポート内のビットの対応関係が判明しました。以下はその対応表です：

### 4×4マトリックス構造

```
  | 0         | 1         | 2         | 3        
--+-----------+-----------+-----------+-----------
0 | byte5_bit5 | byte1_bit0 | byte1_bit1 | byte5_bit0 |
1 | byte4_bit0 | byte5_bit1 | byte4_bit3 | byte4_bit7 |
2 | byte4_bit1 | byte4_bit5 | byte5_bit3 | byte4_bit6 |
3 | byte4_bit4 | byte5_bit4 | byte4_bit2 | byte5_bit2 |
```

### 個別キー情報

各キーの位置と対応するビット、及びその変化頻度は以下の通りです：

| マトリックス位置 | バイト・ビット位置 | ビットマスク | 変化回数 |
|----------------|------------------|------------|---------|
| (0, 0)         | byte5_bit5       | 0x20       | 80      |
| (0, 1)         | byte1_bit0       | 0x01       | 78      |
| (0, 2)         | byte1_bit1       | 0x02       | 44      |
| (0, 3)         | byte5_bit0       | 0x01       | 38      |
| (1, 0)         | byte4_bit0       | 0x01       | 36      |
| (1, 1)         | byte5_bit1       | 0x02       | 33      |
| (1, 2)         | byte4_bit3       | 0x08       | 24      |
| (1, 3)         | byte4_bit7       | 0x80       | 24      |
| (2, 0)         | byte4_bit1       | 0x02       | 24      |
| (2, 1)         | byte4_bit5       | 0x20       | 24      |
| (2, 2)         | byte5_bit3       | 0x08       | 24      |
| (2, 3)         | byte4_bit6       | 0x40       | 22      |
| (3, 0)         | byte4_bit4       | 0x10       | 20      |
| (3, 1)         | byte5_bit4       | 0x10       | 20      |
| (3, 2)         | byte4_bit2       | 0x04       | 18      |
| (3, 3)         | byte5_bit2       | 0x04       | 18      |

このデータから、各キー押下時に変化するビットが特定されており、これによってキーボードの状態を正確に解析することができます。

### その他の特徴的なビット

キーボードのエンコーダーやLEDなどの制御に関わると思われるビットも検出されています：

- byte7_bit4: 4回変化
- byte8_bit5: 2回変化
- byte10_bit0: 2回変化
- byte11_bit4: 6回変化

## 実装例

以下はESP32-S3でDOIO KB16キーボードのレポートを処理するための実装例です：

```cpp
// キーボードマトリックスマッピング構造体
struct KeyMapping {
    uint8_t byte_idx;  // レポート内のバイトインデックス
    uint8_t bit_mask;  // ビットマスク
    uint8_t row;       // キーボードマトリックス行
    uint8_t col;       // キーボードマトリックス列
};

// DOIO KB16キーマッピング
const KeyMapping kb16_key_map[] = {
    { 5, 0x20, 0, 0 },  // byte5_bit5
    { 1, 0x01, 0, 1 },  // byte1_bit0
    { 1, 0x02, 0, 2 },  // byte1_bit1
    { 5, 0x01, 0, 3 },  // byte5_bit0
    { 4, 0x01, 1, 0 },  // byte4_bit0
    { 5, 0x02, 1, 1 },  // byte5_bit1
    { 4, 0x08, 1, 2 },  // byte4_bit3
    { 4, 0x80, 1, 3 },  // byte4_bit7
    { 4, 0x02, 2, 0 },  // byte4_bit1
    { 4, 0x20, 2, 1 },  // byte4_bit5
    { 5, 0x08, 2, 2 },  // byte5_bit3
    { 4, 0x40, 2, 3 },  // byte4_bit6
    { 4, 0x10, 3, 0 },  // byte4_bit4
    { 5, 0x10, 3, 1 },  // byte5_bit4
    { 4, 0x04, 3, 2 },  // byte4_bit2
    { 5, 0x04, 3, 3 },  // byte5_bit2
};

// KB16キーボードのレポート解析関数
void onKeyboard(hid_keyboard_report_t report, hid_keyboard_report_t last_report) {
    // DOIO KB16カスタムキー解析
    if (device_product_id == 0x1601 && device_vendor_id == 0xD010) {
        const uint8_t* data = (const uint8_t*)&report;
        const uint8_t* last_data = (const uint8_t*)&last_report;
        bool key_state_changed = false;
        
        // 各キーマッピングをチェック
        for (int i = 0; i < sizeof(kb16_key_map) / sizeof(KeyMapping); i++) {
            const KeyMapping& mapping = kb16_key_map[i];
            
            // バイトインデックスが範囲内か確認
            if (mapping.byte_idx < sizeof(report)) {
                bool current_state = data[mapping.byte_idx] & mapping.bit_mask;
                bool last_state = last_data[mapping.byte_idx] & mapping.bit_mask;
                
                // 状態が変化した場合
                if (current_state != last_state) {
                    key_state_changed = true;
                    // キーの状態変化に応じた処理を実装
                }
            }
        }
    }
}
```

## まとめ

DOIO KB16キーボードは独自のレポート形式を使用していますが、解析の結果、各キーの位置とレポート内のビットの対応関係が明らかになりました。この情報を利用することで、DOIO KB16キーボードとの通信を正確に実装することが可能となります。

本ドキュメントが、DOIO KB16キーボードを利用したプロジェクトの開発に役立つことを願っています。

---
*このドキュメントは解析データに基づいて作成されています。将来のファームウェア更新などによって、レポート形式が変更される可能性があることにご注意ください。*
